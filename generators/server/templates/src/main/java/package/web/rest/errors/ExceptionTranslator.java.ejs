<%#
 Copyright 2013-2022 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
package <%= packageName %>.web.rest.errors;

import static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;

import tech.jhipster.config.JHipsterConstants;
import tech.jhipster.web.util.HeaderUtil;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
<%_ if (!databaseTypeNo && !databaseTypeCassandra) { _%>
import org.springframework.dao.ConcurrencyFailureException;
<%_ } _%>
<%_ if (!databaseTypeNo) { _%>
import org.springframework.dao.DataAccessException;
<%_ } _%>
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConversionException;
<%_ if (reactive && databaseTypeSql) { _%>
import org.springframework.stereotype.Component;
<%_ } _%>
import org.springframework.validation.BindingResult;
import org.springframework.web.ErrorResponseException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
<%_ if (reactive) { _%>
import org.springframework.web.bind.support.WebExchangeBindException;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.http.MediaType;
import tech.jhipster.web.rest.errors.ExceptionTranslation;
import org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
<%_ } _%>
<%_ if (!reactive) { _%>
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
<%_ } _%>
import org.springframework.core.env.Environment;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ProblemDetail;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.ErrorResponse;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.lang.Nullable;
import org.springframework.web.bind.MethodArgumentNotValidException;

<%_ if (reactive) { _%>
import reactor.core.publisher.Mono;
<%_ } _%>

import jakarta.annotation.Nonnull;
<%_ if (!reactive) { _%>
import jakarta.servlet.http.HttpServletRequest;
<%_ } _%>
import java.net.URI;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Controller advice to translate the server side exceptions to client-friendly json structures.
 * The error response follows RFC7807 - Problem Details for HTTP APIs (https://tools.ietf.org/html/rfc7807).
 */
@ControllerAdvice
<%_ if (databaseTypeSql && reactive) { _%>
@Component("jhiExceptionTranslator")
<%_ } _%>
public class ExceptionTranslator extends ResponseEntityExceptionHandler <% if (reactive) { %> implements ExceptionTranslation <% }  %>{

<%_
let returnType;
let requestClass;
let requestEntityRequestClass;
if (reactive) {
    returnType = 'Mono<ResponseEntity<Object>>';
    requestClass = 'ServerWebExchange';
    requestEntityRequestClass = 'ServerWebExchange'
} else {
    returnType = 'ResponseEntity<Object>';
    requestClass = 'NativeWebRequest';
    requestEntityRequestClass = 'WebRequest';
}
_%>
    private static final String FIELD_ERRORS_KEY = "fieldErrors";
    private static final String MESSAGE_KEY = "message";
    private static final String PATH_KEY = "path";
    private static final String VIOLATIONS_KEY = "violations";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final Environment env;

    public ExceptionTranslator(Environment env) {
        this.env = env;
    }
    
    @ExceptionHandler
    <%_ if (reactive) { _%>@Override<%_ } _%>
    public <%- returnType %> handleAnyException(Throwable ex, <%= requestClass %> request
    ) {
        ErrorResponse err = wrapAndCustemizeErrorResponse(ex, request);
        return handleExceptionInternal((Exception) err, null, buildHeaders(err, request), err.getStatusCode(), request);
    }

    @Nullable
    @Override
    protected <%- returnType %> handleExceptionInternal(
            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, <%= requestEntityRequestClass %> request) {
        ErrorResponse err = wrapAndCustemizeErrorResponse((Throwable) ex, (<%= requestClass %>) request);
    <%_ if (reactive) { _%>
        if (request.getResponse().isCommitted()) {
            return Mono.error(ex);
        }
        return Mono.just(new ResponseEntity<>(err.getBody(), updateContentType(headers), err.getStatusCode()));
    <%_ } else { _%>
        return super.handleExceptionInternal(ex, body, headers, statusCode, request);
    <%_ } _%>
    }

    protected ErrorResponse wrapAndCustemizeErrorResponse(Throwable ex, <%= requestClass %> request) {
        return custemizeErrorResponseException(ex instanceof ErrorResponse err ? err : wrapWithErrorResponse(ex), request);
    }

    private ErrorResponseException wrapWithErrorResponse(Throwable ex) {
<%_ if (!skipUserManagement) { _%>
        if(ex instanceof tech.jhipster.sample.service.EmailAlreadyUsedException)
            return new EmailAlreadyUsedException();
        if(ex instanceof tech.jhipster.sample.service.UsernameAlreadyUsedException )
            return new LoginAlreadyUsedException();
        if(ex instanceof tech.jhipster.sample.service.InvalidPasswordException )
            return new InvalidPasswordException();
<%_ } _%>
        if(ex instanceof ErrorResponseException exp)
            return exp;
        return new ErrorResponseException(toStatus(ex), ex);
    }

    protected ErrorResponse custemizeErrorResponseException(ErrorResponse err, <%= requestClass %> request) {
        if(err.getStatusCode() == null)
            err.getBody().setStatus(toStatus((Throwable) err));
        
        if(err.getBody().getType() == null)
            err.getBody().setType(getMappedType((Throwable) err));
        
        // higher precedence to Custom/ResponseStatus types
        String title = extractTitle(err);
        if(err.getBody().getTitle() == null || !err.getBody().getTitle().equals(title)) {
            err.getBody().setTitle(title);
        }
        
        if(err.getBody().getDetail() == null) {
         // higher precedence to cause
            err.getBody().setDetail(((Throwable) err).getCause() != null ? ((Throwable) err).getCause().getMessage() : ((Throwable) err).getMessage());
        }
        
        if(err.getBody().getProperties() == null || !err.getBody().getProperties().containsKey(MESSAGE_KEY))
            err.getBody().setProperty(MESSAGE_KEY, getMappedMessageKey((Throwable) err) != null ? getMappedMessageKey((Throwable) err) : "error.http." + err.getStatusCode().value());
        
        if(err.getBody().getProperties() == null || !err.getBody().getProperties().containsKey(PATH_KEY))
            err.getBody().setProperty(PATH_KEY, getPathValue(request));
        
        if((err instanceof <% if (reactive) { %> WebExchangeBindException <% } else { %> MethodArgumentNotValidException <% } %>) && 
                (err.getBody().getProperties() == null || !err.getBody().getProperties().containsKey(FIELD_ERRORS_KEY)))
            err.getBody().setProperty(FIELD_ERRORS_KEY, getFieldErrors((<% if (reactive) { %>WebExchangeBindException<% } else { %>MethodArgumentNotValidException<% } %>) err));
        
        return err;
    }

    private String extractTitle(ErrorResponse err) {
        return getCustemizedTitle((Throwable) err) != null ? getCustemizedTitle((Throwable) err) : extractTitleForResponseStatus(err);
    }

    private List<FieldErrorVM> getFieldErrors(<% if (reactive) { %>WebExchangeBindException<% } else { %>MethodArgumentNotValidException<% } %> ex) {
        return ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(f ->
                new FieldErrorVM(
                    f.getObjectName().replaceFirst("<%= dtoSuffix %>$", ""),
                    f.getField(),
                    StringUtils.isNotBlank(f.getDefaultMessage()) ? f.getDefaultMessage() : f.getCode()
                )
            )
            .collect(Collectors.toList());
    }

    private String extractTitleForResponseStatus(ErrorResponse err) {
        ResponseStatus specialStatus = extractResponseStatus((Throwable) err);
        String title = specialStatus == null ? HttpStatus.valueOf(err.getStatusCode().value()).getReasonPhrase() : specialStatus.reason();
        return title;
    }

<%_ if (!reactive) { _%>
    private String extractURI(<%= requestClass %> request) {
        HttpServletRequest nativeRequest = request.getNativeRequest(HttpServletRequest.class);
        String requestUri = nativeRequest != null ? nativeRequest.getRequestURI() : StringUtils.EMPTY;
        return requestUri;
    }
<%_ } _%>
    private HttpStatus toStatus(final Throwable throwable) {
        // Let the ErrorResponse take this responsibility
        if (throwable instanceof ErrorResponse err) return HttpStatus.valueOf(err.getBody().getStatus());

        return Optional
                .ofNullable(getMappedStatus(throwable))
                .orElse(Optional
                        .ofNullable(resolveResponseStatus(throwable))
                        .map(response -> response.value())
                        .orElse(HttpStatus.INTERNAL_SERVER_ERROR));
    }

    private ResponseStatus extractResponseStatus(final Throwable throwable) {
        return Optional.ofNullable(resolveResponseStatus(throwable))
                .orElse(null);
    }

    private ResponseStatus resolveResponseStatus(final Throwable type) {
        final ResponseStatus candidate = findMergedAnnotation(type.getClass(), ResponseStatus.class);
        return candidate == null && type.getCause() != null ? resolveResponseStatus(type.getCause()) : candidate;
    }

    private URI getMappedType(Throwable err) {
        if(err instanceof MethodArgumentNotValidException exp)
            return ErrorConstants.CONSTRAINT_VIOLATION_TYPE;
        return ErrorConstants.DEFAULT_TYPE;
    }
    
    private String getMappedMessageKey(Throwable err) {
        if(err instanceof MethodArgumentNotValidException)
            return ErrorConstants.ERR_VALIDATION;
    <%_ if (!databaseTypeNo && !databaseTypeCassandra) { _%>
        else if(err instanceof ConcurrencyFailureException 
                || err.getCause() != null && err.getCause() instanceof ConcurrencyFailureException)
            return ErrorConstants.ERR_CONCURRENCY_FAILURE;
    <%_ } _%>
    <%_ if (reactive) { _%>
        else if (err instanceof WebExchangeBindException) return ErrorConstants.ERR_VALIDATION;
    <%_ } _%>
        return null;
    }
    
    private String getCustemizedTitle(Throwable err) {
        if(err instanceof MethodArgumentNotValidException exp)
            return "Method argument not valid";
        return null;
    }
    
    private HttpStatus getMappedStatus(Throwable err) {
        // Where we disagree with Spring defaults
        if (err instanceof AccessDeniedException accDenied) return HttpStatus.FORBIDDEN;
    <%_ if (!databaseTypeNo && !databaseTypeCassandra) { _%>
        if(err instanceof ConcurrencyFailureException) return HttpStatus.CONFLICT;
    <%_ } _%>    
        if(err instanceof BadCredentialsException) return HttpStatus.UNAUTHORIZED;
    <%_ if (reactive) { _%>
        if (err instanceof UsernameNotFoundException) return HttpStatus.UNAUTHORIZED;
    <%_ } _%>
        return null;
    }
    
    private URI getPathValue(<%= requestClass %> request) {
        if(request == null) return URI.create("about:blank");
        return <% if (reactive) { %> request.getRequest().getURI()<% } else { %> URI.create(extractURI((NativeWebRequest) request))<% } %>;
    }

    private HttpHeaders buildHeaders(ErrorResponse err, <%= requestClass %> request) {
        return err instanceof BadRequestAlertException ? 
                HeaderUtil.createFailureAlert(applicationName, true, ((BadRequestAlertException) err).getEntityName(),
                        ((BadRequestAlertException) err).getErrorKey(), ((BadRequestAlertException) err).getMessage()) : null;
    }
<%_ if (reactive) { _%>
    private HttpHeaders updateContentType(HttpHeaders headers) {
        if(headers == null) {
            headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_PROBLEM_JSON);
        }
        return headers;
    }
<%_ } _%>
/*
    @Override
    public ProblemBuilder prepare(final Throwable throwable, final StatusType status, final URI type) {
        Collection<String> activeProfiles = Arrays.asList(env.getActiveProfiles());

        if (activeProfiles.contains(JHipsterConstants.SPRING_PROFILE_PRODUCTION)) {
            if (throwable instanceof HttpMessageConversionException) {
                return Problem.builder()
                    .withType(type)
                    .withTitle(status.getReasonPhrase())
                    .withStatus(status)
                    .withDetail("Unable to convert http message")
                    .withCause(Optional.ofNullable(throwable.getCause())
                        .filter(cause -> isCausalChainsEnabled())
                        .map(this::toProblem)
                        .orElse(null));
            }
<%_ if (!databaseTypeNo) { _%>
            if (throwable instanceof DataAccessException) {
                return Problem.builder()
                    .withType(type)
                    .withTitle(status.getReasonPhrase())
                    .withStatus(status)
                    .withDetail("Failure during data access")
                    .withCause(Optional.ofNullable(throwable.getCause())
                        .filter(cause -> isCausalChainsEnabled())
                        .map(this::toProblem)
                        .orElse(null));
            }
<%_ } _%>
            if (containsPackageName(throwable.getMessage())) {
                return Problem.builder()
                    .withType(type)
                    .withTitle(status.getReasonPhrase())
                    .withStatus(status)
                    .withDetail("Unexpected runtime exception")
                    .withCause(Optional.ofNullable(throwable.getCause())
                        .filter(cause -> isCausalChainsEnabled())
                        .map(this::toProblem)
                        .orElse(null));
            }
        }

        return Problem.builder()
            .withType(type)
            .withTitle(status.getReasonPhrase())
            .withStatus(status)
            .withDetail(throwable.getMessage())
            .withCause(Optional.ofNullable(throwable.getCause())
                .filter(cause -> isCausalChainsEnabled())
                .map(this::toProblem)
                .orElse(null));
    }

    private boolean containsPackageName(String message) {

        // This list is for sure not complete
        return StringUtils.containsAny(message, "org.", "java.", "net.", "jakarta.", "javax.", "com.", "io.", "de.", "<%= packageName %>");
    }
*/
}
